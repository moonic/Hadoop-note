# MRv2 Node Manager

* NodeManager（NM）是YARN中每个节点上的代理
  * 管理Hadoop集群中单个计算节点，包括与ResourceManger保持通信
  * 监督Container的生命周期管理
  * 监控每个Container的资源使用（内存、CPU等）情况，追踪节点健康状况
  * 管理日志和不同应用程序用到的附属服务（auxiliary service）。

### NodeStatusUpdater
 
* 当NM启动时，该组件向RM注册，并发送节点上可用资源
* 接下来，NM与RM通信，汇报各个Container的状态更新，包括节点上正运行的Container、已完成的Contaner等。
* 此外，RM可能向NodeStatusUpdater发信号，杀死处于运行中的Container。
> 注：NodeStatusUpdater是NM与RM通信的唯一通道，它实际上是RPC协议ResourceTracker的client，它周期性地调用RPC函数nodeHeartbeat()向RM汇报本节点上各种信息，包括资源使用情况，各个Container运行情况等。
 
### ContainerManager
* 它是NodeManager中核心组件，它由以下几个子组件构成
* 每个子组件负责一部分功能，以管理运行在该节点上的所有Container
* （注意，ContainerManager实际上是个接口，真正的实现是ContainerManagerImpl类）

1. RPC Server ContainerManager从各个Application Master上接收RPC请求以启动Container或者停止正在运行的Container。它与ContainerTokenSecretManager（下面将介绍）合作，以对所有请求进行合法性验证。所有作用在正运行Container的操作均会被写入audit-log，以便让安全工具进行后续处理。
注：这里的“RPC Server”实际上是RPC协议ContainerManager的server，AM可通过该协议通知某个节点启动或者释放container，ContainerManager定义了三个接口供AM使用：

StartContainerResponse startContainer(StartContainerRequest request); //启动container
StopContainerResponse stopContainer(StopContainerRequest request); //释放container
GetContainerStatusResponse getContainerStatus(GetContainerStatusRequest request);//获取container列表。

2. ResourceLocalizationService 负责（从HDFS上）安全地下载和组织Container需要的各种文件资源。它尽量将文件分摊到各个磁盘上。它会为下载的文件添加访问控制限制，并为之施加合适的（磁盘空间）使用上限。
注：该服务会采用多线程方式同时从HDFS上下载文件，并按照文件类型（public或者private文件）存放到不同目录下，并为目录设置严格的访问权限，同时，每个用户可使用的磁盘空间大小也可以设置。
3. ContainersLauncher 维护了一个线程池，随时准备并在必要时尽快启动Container，同时，当收到来自RM或者 ApplicationMaster的清理Container请求时，会清理对应的Container进程。
4. AuxServices NM提供了一个框架以通过配置附属服务扩展自己的功能，这允许每个节点定制一些特定框架可能需要的服务，当然，这些服务是与NM其他服务隔离开的（有自己的安全验证机制）。附属服务需要在NM启动之前配置好，且由对应应用程序的运行在本节点上的第一container触发启动。
5. ContainersMonitor 当一个Container启动之后，该组件便开始观察它在运行过程中的资源利用率。为了实现资源隔离和公平共享，RM为每个Container分配了一定量的资源。ContainersMonitor持续监控每个Container的利用率，一旦一个Container超出了它的允许使用份额，它将向Container发送信号将其杀掉，这可以避免失控的Container影响了同节点上其他正在运行的Container。（注意，ContainersMonitor实际上是个接口，真正的实现是ContainersMonitorImpl类）。
注：NM启动一个container后，ContainersMonitor会将该container进程对一个的pid添加到监控列表中，以监控以pid为根的整棵进程树的资源使用情况，它周期性地从/etc/proc中获取进程树使用的总资源，一旦发现超过了预期值，则会将其杀死。在最新版YARN中，已采用了Linux container对资源进行隔离。
6. LogHandler 一个可插拔组件，用户通过它可选择将Container日志写到本地磁盘上还是将其打包后上传到一个文件系统中。

### ContainerExecutor
与底层操作系统交互，安全存放Container需要的文件和目录，进而以一种安全的方式启动和清除Container对应的进程。
注：在最新版YARN中，已采用了Linux container对资源进行隔离

### NodeHealthCheckerService
提供以下功能：通过周期性地运行一个配置好的脚本检查节点的健康状况
它也会通过周期性地在磁盘上创建临时文件以监控磁盘健康状况
任何系统健康方面的改变均会通知NodeStatusUpdater（前面已经介绍过），它会进一步将信息传递给RM。


### Security
1. ApplicationACLsManager NM需要为所有面向用户的API提供安全检查，如在Web-UI上只能将container日志显示给授权用户。该组件为每个应用程序维护了一个ACL列表，一旦收到类似请求后会利用该列表对其进行验证。
2. ContainerTokenSecretManager 检查收到的各种访问请求的合法性，确保这些请求操作已被RM授权。

### WebServer
在给定时间点，展示该节点上所有应用程序和container列表，节点健康相关的信息和container产生的日志。

* 主要功能亮点
启动Container
为了能够启动Container，NM期望收到的Container定义了关于它运行时所需的详细信息，包括运行container的命令、环境变量、所需的资源列表和安全令牌等。
一旦收到container启动请求，如果YARN启用了安全机制，则NM首先验证请求合法性以对用户和正确的资源分配进行授权。之后，NM将按照以下步骤启动一个container：
1. 在本地拷贝一份运行Container所需的所有资源（通过Distributed Cache实现）。
2. 为container创建经隔离的工作目录，并在这些目录中准备好所有（文件）资源。
3. 运行命令启动container
  * 日志聚集
    * 与MRv1不同，NM不再截取日志并将日志留单个节点（TaskTracker）上，而是将日志上传到一个文件系统中
    * 比如HDFS，以此来解决日志管理问题。
    * 在某个NM上，所有属于同一个应用程序的container日志经聚集后被写到（可能经过压缩处理）一个FS上的日志文件中，用户可通过YARN命令行工具，WEB-UI或者直接通过FS访问这些日志。

* MapReduce shuffle如何利用NM的附属服务
  * 运行MapReduce程序所需的shuffle功能是通过附属服务实现的，该服务会启动一个Netty Server，它知道如何处理来自Reduce Task的MR相关的shuffle请求。
  * MR（MapReduce） AM（ApplicationMaster）为shuffle服务定义了服务ID，和可能需要的安全令牌，而NM向AM提供shuffle服务的运行端口号，并由AM传递给各个Reduce Task。

* 在YARN中，NodeManager主要用于管理抽象的container
  * 它只处理container相关的事情，而不必关心每个应用程序（如MapReduce Task）自身的状态管理
  * 不再有类似于map slot和reduce slot的slot概念，正是由于上述各个模块间清晰的责任分离，NM可以很容易的扩展，且它的代码也更容易维护。

##  MRv2 Node Manager—Application状态机分析

* Application是NodeManager中用于维护一个Application生命周期的数据结构
* 它的实现是ApplicationImpl，该类维护了一个Application状态机，记录了Application可能存在的各个状态以及导致状态间转换的事件，当某个事件发时，ApplicationImpl会根据实际情况进行节点状态转移，同时触发一个行为。

如图所示，在NM看来，每个节点有5种基本状态（ApplicationState）和8种导致这5种状态之间发生转移的事件（ApplicationEventType），ApplicationImpl的作用是等待接收其他对象发出的ApplicationEventType类型的事件，然后根据当前状态和事件类型，将当前状态转移到另外一种状态，同时触发另外一种行为（实际上执行一个函数，该函数可能会再次发出一种其他类型的事件）。下面具体进行介绍：
基本事件
（1） INIT_APPLICATION
NodeManager收到来自某个Application的第一个container，则会触发一个INIT_APPLICATION事件，同时使Application状态由初始状态NEW转换为INITING。
（2）FINISH_APPLICATION
NodeManager通过心跳机制收到ResourceManager发送的待清理的Application列表后，会为这些application发送一个FINISH_APPLICATION事件。
（3）APPLICATION_CONTAINER_FINISHED
该Application的一个container退出（可能运行失败，也可能运行成功。）
（4）APPLICATION_INITED
Application本地化完成（在每个NodeManager上，对于同一个Application，由第一个container负责Application级别的本地化工作，后续的container只需负责自己的本地化工作。本地化涉及到的主要工作是准备执行环境，包括准备各种jar包，二进制文件，外部文件等。）
（5）APPLICATION_RESOURCES_CLEANEDUP
NodeManager清理Application占用的临时目录，该过程与Application本地化是一对逆过程。
（6）INIT_CONTAINER
NodeManager收到一个ApplicationMaster启动container的请求（通过RPC函数ContainerManager.startContainer()）后，会触发一个INIT_CONTAINER事件。
（7）APPLICATION_LOG_HANDLING_INITED
Application触发INIT_APPLICATION事件的同时，会执行一个函数，该函数会进一步触发APPLICATION_LOG_HANDLING_INITED事件。
（8）APPLICATION_LOG_HANDLING_FINISHED
Application运行完成，资源得到回收后，会触发一个APPLICATION_LOG_HANDLING_FINISHED事件，销毁log句柄。
下图描述了以上各个事件的来源

##  Container启动过程分析
Container启动命令是由各个ApplicationMaster通过RPC函数ContainerManager.startContainer()向NodeManager发起的，Container启动过程主要经历三个阶段：资源本地化、启动并运行container、资源回收，其中，资源本地化指创建container工作目录，从HDFS下载运行container所需的各种资源（jar包、可执行文件等）等，而资源回收则是资源本地化的逆过程，它负责清理各种资源，它们均由ResourceLocalizationService服务完成的。启动container是由ContainersLauncher服务完成的，而运行container是由插拔式组件ContainerExecutor完成的，YARN提供了两种ContainerExecutor实现，一种是DefaultContainerExecutor，另一种是LinuxContainerExecutor。
资源本地化
资源本地化是指准备container运行所需的环境，包括创建container工作目录，从HDFS下载运行container所需的各种资源（jar包、可执行文件等）等。
YARN将资源分为两类，一类是public级别的资源，这类资源被放到一个公共目录下，由所有用户共享，另一类是private级别的资源，这类资源是用户私有的，只能在所属用户的各个作业间共享。资源本地化过程实际上就是准备public和private资源的过程，它由ResourceLocalizationService服务完成，其中，所有application的public资源由专门的线程PublicLocalizer下载完成，该线程内部维护了一个线程池以加快资源下载速度，每个application的private资源由一个专门的线程LocalizerRunner下载完成。
启动Container
启动Container是由ContainersLauncher完成的，该过程主要工作是将运行container对应的完整shell命令写到私有目录下的launch_container.sh中，并将token文件写到container_tokens中。之所以要将container运行命令写到launch_container.sh中，然后通过运行shell脚本的形式运行container，主要是因为直接执行命令可能会有些特殊符号不识别。
运行Container
而运行container是由插拔式组件ContainerExecutor完成的，YARN提供了两种ContainerExecutor实现，一种是DefaultContainerExecutor，另一种是LinuxContainerExecutor。DefaultContainerExecutor只是简单的以管理员身份运行launch_container.sh脚本，而LinuxContainerExecutor则是以container所属用户身份运行该脚本，它是Hadoop引入安全机制后加入的，此外，在不久的将来，container会引入cgroups隔离cpu资源，相关的代码也会存放在LinuxContainerExecutor中。
资源回收
资源回收由ResourceLocalizationService服务完成的，该过程与资源本地化正好相反，它负责撤销container运行过程中使用的各种资源。
资源隔离方案
YARN对内存资源和CPU资源采用了不同的资源隔离方案。对于内存资源，为了能够更灵活的控制内存使用量，YARN采用了进程监控的方案控制内存使用，即每个NodeManager会启动一个额外监控线程监控每个container内存资源使用量，一旦发现它超过约定的资源量，则会将其杀死。采用这种机制的另一个原因是Java中创建子进程采用了fork()+exec()的方案，子进程启动瞬间，它使用的内存量与父进程一致，从外面看来，一个进程使用内存量可能瞬间翻倍，然后又降下来，采用线程监控的方法可防止这种情况下导致swap操作。对于CPU资源，则采用了Cgroups进行资源隔离。

## Container状态机分析
Container是NodeManager中用于维护一个Container生命周期的数据结构，它的实现是ContainerImpl，该类维护了一个Container状态机，记录了Container可能存在的各个状态以及导致状态间转换的事件，当某个事件发生时，ContainerImpl会根据实际情况进行节点状态转移，同时触发一个行为。

如图所示，在NM看来，每个节点有10种基本状态（ContainerState）和10种导致这10种状态之间发生转移的事件（ContainerEventType），ContainerImpl的作用是等待接收其他对象发出的ContainerEventType类型的事件，然后根据当前状态和事件类型，将当前状态转移到另外一种状态，同时触发另外一种行为（实际上执行一个函数，该函数可能会再次发出一种其他类型的事件）。下面具体进行介绍：
基本事件
（1） INIT_CONTAINER
NodeManager收到来自某个ApplicationMaster的启动container请求（通过RPC函数ContainerManager.startContainer()），则会触发一个INIT_CONTAINER事件，同时使container状态由初始状态NEW转换为LOCALIZING。
（2）RESOURCE_LOCALIZED
Container完成本地化工作（主要工作是从HDFS上下载各种文件，包括jar包，二进制文件和其他container执行过程中需用到的文件），会触发一个RESOURCE_LOCALIZED事件。
（3）CONTAINER_LAUNCHED
Container成功启动后，会触发一个CONTAINER_LAUNCHED事件，使得Container从LOCALIZED状态转换为CONTAINER_LAUNCHED状态。
（4） CONTAINER_EXITED_WITH_SUCCESS
Container正常退出（Container实际上是一个shell命令，正常结束运行后会返回0），会触发一个CONTAINER_EXITED_WITH_SUCCESS事件。
（5）CONTAINER_RESOURCES_CLEANEDUP
NodeManager清理完成Container使用的各种临时目录，此时会触发一个CONTAINER_RESOURCES_CLEANEDUP事件，使得Container从EXITED_WITH_SUCCESS状态转换为DONE状态。
（6）RESOURCE_FAILED
Container本地化过程中抛出异常，会触发一个RESOURCE_FAILED事件，导致Container失败。
（7）KILL_CONTAINER
在多种场景下会触发产生KILL_CONTAINER事件，包括：1）ResourceManager要求NodeManager杀死一个container  2）Container使用的内存量超过约定值，被监控线程杀死 3）ApplicationMaster要求NodeManager杀死一个container（通过RPC函数ContainerManager.stopContainer()） 4）Container正常运行结束（正如MRv1中Task结束后会收到KilledTaskAction一样，container结束也会收到KILL_CONTAINER）
（8）CONTAINER_EXITED_WITH_FAILURE
Container异常退出（运行过程中抛出Throwable异常）
（9）CONTAINER_KILLED_ON_REQUEST
Container运行过程中被强制杀死或者终止（返回码为137或者143）。
（10）UPDATE_DIAGNOSTICS_MSG
执行ContainerExecutor. launchContainer()过程中抛出IOException异常（ContainerExecutor有两种实现，默认是DefaultContainerExecutor，另一种是LinuxContainerExecutor）。


## LocalizedResource状态机分析
LocalizedResource是NodeManager中用于维护一种”资源”生命周期的数据结构，它维护了一个状态机，记录了“资源”可能存在的各个状态以及导致状态间转换的事件，当某个事件发生时，LocalizedResource会根据实际情况进行节点状态转移，同时触发一个行为。

如图所示，在NM看来，每个节点有3种基本状态（ResourceState）和3种导致这3种状态之间发生转移的事件（ResourceEventType），LocalizedResource的作用是等待接收其他对象发出的ResourceEventType类型的事件，然后根据当前状态和事件类型，将当前状态转移到另外一种状态，同时触发另外一种行为（实际上执行一个函数，该函数可能会再次发出一种其他类型的事件）。下面具体进行介绍：
基本事件
（1）REQUEST
当需要为container下载某种资源时（比如jar包或者字典文件，这些文件一般位于HDFS上，需要在container执行前下载到本地），会发出一个REQUEST事件。
（2）LOCALIZED
一种资源下载成功后，会触发一个LOCALIZED事件。
（3）RELEASE
当Container执行完成（可能成功或者失败）后，会触发一个RELEASE事件，已清理各种存放在本地的资源。
